use leansig_core::{
    AggregatedSignature, AggregatedVerifier, Message, Signer, ValidatorSignature,
    spec::{self, Spec},
};
use leansig_shared::PublicInputs;
// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{XMSS_AGGREGATE_ELF, XMSS_AGGREGATE_ID};
use rand::{SeedableRng as _, rngs::StdRng};
use risc0_zkvm::{ExecutorEnv, default_prover};

fn create_test_data(num_validators: usize, spec: Spec) -> (PublicInputs, AggregatedSignature) {
    let message = Message([42; 32]);
    let epoch = 0;

    let mut validators: Vec<Signer> = (0..num_validators)
        .map(|i| Signer::new(StdRng::seed_from_u64(i as u64 + 1), 10000, spec.clone(), 4))
        .collect();

    let validator_roots: Vec<_> = validators.iter().map(|v| v.root.clone()).collect();
    let validator_params: Vec<_> = validators.iter().map(|v| v.param.clone()).collect();

    // Each validator signs the message
    let validator_signatures: Vec<ValidatorSignature> = validators
        .iter_mut()
        .map(|validator| {
            let signature = validator.sign(epoch, &message).expect("Failed to sign");
            ValidatorSignature {
                epoch,
                signature,
                xmss_root: validator.root.clone(),
                param: validator.param.clone(),
            }
        })
        .collect();

    let aggregated = AggregatedSignature::new(validator_signatures);

    let public_inputs = PublicInputs {
        message,
        epoch,
        validator_roots,
        validator_params,
        spec,
    };

    (public_inputs, aggregated)
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let (public_inputs, aggregated_signature) = create_test_data(3, spec::SPEC_2);

    // Sanity check the signature verification
    let verifier = AggregatedVerifier::new(
        public_inputs.validator_roots.clone(),
        public_inputs.spec.clone(),
    );
    assert!(
        verifier.verify(&public_inputs.message, &aggregated_signature),
        "failed to verify aggregated signature"
    );

    // Send both public inputs and the aggregated signature to the guest
    let env = ExecutorEnv::builder()
        .write(&public_inputs)
        .unwrap()
        .write(&aggregated_signature)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();
    let prove_info = prover.prove(env, XMSS_AGGREGATE_ELF).unwrap();

    let receipt = prove_info.receipt;
    let _committed_public_inputs: PublicInputs = receipt.journal.decode().unwrap();
    receipt.verify(XMSS_AGGREGATE_ID).unwrap();
}
