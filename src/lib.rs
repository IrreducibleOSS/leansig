use hash_chain::hash_chain;
use rand::{RngCore, rngs::StdRng};
use spec::Spec;

use crate::hash::Hash;

mod code;
mod hash;
mod hash_chain;

pub mod spec;

const MESSAGE_LEN: usize = 32;
const RAND_LEN: usize = 23;

#[derive(Clone)]
struct Nonce(pub [u8; RAND_LEN]);

impl Nonce {
    /// Generate a random nonce.
    pub fn random(rng: &mut StdRng) -> Nonce {
        let mut nonce = Nonce([0; RAND_LEN]);
        rng.fill_bytes(&mut nonce.0);
        nonce
    }
}

impl AsRef<[u8]> for Nonce {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

pub struct Message(pub [u8; MESSAGE_LEN]);

impl AsRef<[u8]> for Message {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

#[derive(Clone, Debug)]
pub struct Param {
    data: Vec<u8>,
}

impl Param {
    pub fn random(param_len: usize, rng: &mut StdRng) -> Self {
        let mut data = vec![0; param_len];
        rng.fill_bytes(&mut data);
        Self { data }
    }
}

impl AsRef<[u8]> for Param {
    fn as_ref(&self) -> &[u8] {
        &self.data
    }
}

/// A public key.
#[derive(Clone, Debug)]
pub struct Pk {
    param: Param,
    end_hashes: Vec<Hash>,
}

impl Pk {
    pub fn derive(sk: &Sk, spec: &Spec) -> Self {
        let param = sk.param.clone();
        let chain_len = spec.chain_len();
        let end_hashes = sk
            .start_hashes
            .iter()
            .enumerate()
            .map(|(chain_index, start_hash)| {
                hash_chain(
                    &param,
                    chain_index,
                    *start_hash,
                    /* start pos */ 0,
                    chain_len - 1,
                )
            })
            .collect();
        Self { param, end_hashes }
    }
}

/// A secret key.
#[derive(Clone, Debug)]
pub struct Sk {
    param: Param,
    start_hashes: Vec<Hash>,
}

impl Sk {
    pub fn random(rng: &mut StdRng, param: Param, spec: &Spec) -> Self {
        let start_hashes = (0..spec.dimension()).map(|_| Hash::random(rng)).collect();
        Self {
            param,
            start_hashes,
        }
    }
}

#[derive(Clone)]
pub struct Signature {
    nonce: Nonce,
    hashes: Vec<Hash>,
}

pub struct Signer {
    rng: StdRng,
    /// The number of times we try to grind the message.
    max_retries: usize,
    /// The specification for this signature scheme.
    spec: Spec,
}

impl Signer {
    pub fn new(rng: StdRng, max_retries: usize, spec: Spec) -> Self {
        Self {
            rng,
            max_retries,
            spec,
        }
    }

    /// Generate a random key pair.
    pub fn gen_pair(&mut self) -> (Sk, Pk) {
        let param = Param::random(self.spec.param_len, &mut self.rng);
        let sk = Sk::random(&mut self.rng, param.clone(), &self.spec);
        let pk = Pk::derive(&sk, &self.spec);
        (sk, pk)
    }

    /// Sign the given message with a secret key and produce a signature.
    ///
    /// In some unlikely cases we may fail to produce a signature. The probability of that is
    /// inversely proportional to the number of retries.
    pub fn sign(&mut self, sk: &Sk, message: &Message) -> Option<Signature> {
        let (codeword, rho) = code::grind(
            &self.spec,
            self.max_retries,
            &sk.param,
            message,
            &mut self.rng,
        )?;
        assert_eq!(codeword.dimension(), self.spec.dimension());

        let start_hashes = sk.start_hashes.iter();
        let coords = codeword.coords().iter().map(|&coords| coords as usize);
        let hashes = start_hashes
            .zip(coords)
            .enumerate()
            .map(|(chain_index, (start_hash, start_pos))| {
                hash_chain(&sk.param, chain_index, *start_hash, 0, start_pos)
            })
            .collect();

        Some(Signature { nonce: rho, hashes })
    }

    /// Verify a signature.
    ///
    /// Given the public key, signature and the message, returns whether the signature was plausibly
    /// generated by the private key corresponding to the public key.
    pub fn verify(&self, pk: &Pk, signature: &Signature, message: &Message) -> bool {
        let Some(codeword) = code::new_valid(&self.spec, &pk.param, message, &signature.nonce)
        else {
            // The specified message combined with `nonce` does not provide a valid codeword.
            return false;
        };
        assert_eq!(codeword.dimension(), self.spec.dimension());

        let chain_len = self.spec.chain_len();
        let hashes = signature.hashes.iter();
        let coords = codeword.coords().iter().map(|&coord| coord as usize);
        let end_hashes = hashes
            .zip(coords)
            .enumerate()
            .map(|(chain_index, (hash, hash_pos))| {
                hash_chain(
                    &pk.param,
                    chain_index,
                    *hash,
                    hash_pos,
                    chain_len - 1 - hash_pos,
                )
            });

        end_hashes.eq(pk.end_hashes.iter().cloned())
    }
}

#[cfg(test)]
mod tests {
    use crate::spec::Spec;

    use super::*;
    use rand::SeedableRng;
    fn sign(spec: Spec) {
        let mut signer = Signer::new(StdRng::from_os_rng(), 1000000, spec);
        let (sk, pk) = signer.gen_pair();
        let message = Message([1; 32]);
        let Some(signature) = signer.sign(&sk, &message) else {
            panic!("Failed to sign");
        };
        assert!(signer.verify(&pk, &signature, &message));
    }

    #[test]
    fn test_spec_1() {
        sign(spec::SPEC_1);
    }

    #[test]
    fn test_spec_2() {
        sign(spec::SPEC_2);
    }
}
